# 编译器内存泄漏复盘：19行代码如何解决10GB内存溢出

## 1. 现象
在运行 BigInt 版本的斐波那契数列（迭代法）时，随着循环进行，内存占用线性飙升，计算第 100 万项时占用超过 10GB。

## 2. 核心误区：静态编译的陷阱
编译器的旧逻辑陷入了一个常见的**静态分析误区**：
> "如果在 AST 中遇到了 `VarDecl`（变量声明）节点，说明这里是一个**新**变量。新变量的内存肯定是干净的，不需要清理旧数据。"

这个假设在**直线形代码**中是成立的。但是，当 `VarDecl` 出现在 `while` 或 `for` **循环**内部时：
- 代码文本只写了一次声明。
- 但机器码会执行无数次。
- 只有第一次执行是真正的“新变量”（指针为空）。
- 后续每一次循环执行到这里，栈上的指针变量**已经持有**了上一轮循环遗留的数据。

旧逻辑导致编译器生成了“只管申请，不管清理”的代码。每一次循环，变量指针都被直接覆写为新的堆地址，而旧地址的内容（上一轮循环产生的 BigInt）就这样丢失了（Leak）。

## 3. 破局思路：从“我是新的”到“检查我是否旧的”
修复的核心在于转变思维：**编译器不能预判运行时状态**。
我们必须把“判断是否需要释放内存”这个动作，从**编译时（Compiler Time）** 推迟到 **运行时（Runtime）**。

## 4. 关键修复（那19行代码）
我们做了两个简单的改动，实现了逻辑的闭环：

### 4.1 铺垫：入口清零 (`get_entry_alloca`)
首先，确保无论是否进入循环，所有 BigInt 指针变量在函数一开始都被初始化为 `NULL`。这是为了让第一次检查时能安全通过。
```python
# 修改前：未初始化（可能是栈上的随机垃圾值，导致Free崩溃）
# 修改后：
zero_const = ir.Constant(typ, None)
self.builder.store(zero_const, var_addr)
```

### 4.2 绝杀：无条件检查 (`visit_vardecl`)
即使是处理“变量声明”语句，生成的代码也不再假设它是新的。
生成的 IR 逻辑变成了：
1.  **Check**: 这个变量现在指向哪里？是 `NULL` 吗？
2.  **Free**: 如果不是 `NULL`（说明这是循环跑回来的，或者被重用了），**先释放**它指向的内存！
3.  **Alloc**: 现在安全了，申请新内存赋值给它。

```python
# 逻辑伪代码对比

# --- 旧逻辑 (Static Assumption) ---
# 编译器认为：这里是声明，肯定没旧值
ptr = malloc(BigInt) 
# 结果：如果 ptr 之前指着 1GB 数据，那 1GB 就丢了


# --- 新逻辑 (Runtime Check) ---
# 编译器认为：不管是不是声明，先检查一下底细
if (ptr != NULL) {
    free(ptr->data)  # 洗碗：释放旧数据
    free(ptr)
}
ptr = malloc(BigInt) # 盛饭：装新数据
```

## 5. 总结
这“19行代码”的价值在于它修正了编译器对**作用域（Scope）和生命周期（Lifetime）** 的理解。

在编译原理中，对于**循环结构**内部定义的局部变量，**静态的“声明点”不等于动态的“生命周期开始点”**。如果变量持有堆内存资源（如 BigInt, String），编译器必须引入**运行时检查**机制，实现“自适应”的内存回收，也就是俗称的“用之前先洗碗”。
