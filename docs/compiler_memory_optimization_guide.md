# 编译器开发实战：记一次 10GB 内存泄漏的排查与优化

> **摘要**：在实现一门编程语言的 BigInt 支持时，我们遭遇了严重的内存泄漏问题——计算第 100 万项斐波那契数列竟消耗了 10GB 内存。本文详细记录了从现象发现、原理解析到最终修复的全过程，揭示了编译器开发中关于**变量生命周期**与**运行时资源管理**的两个关键陷阱。

---

## 1. 案发现场：失控的内存

我们在 Meteor 语言中实现了一个标准的 BigInt（大整数）类型，并使用经典的迭代法计算斐波那契数列进行测试：

```meteor
# fib_bigint.met
c: bigint = a + b
a = b
b = c
```

逻辑看似简单，但在计算 `n=1000000` 时，通过任务管理器观察到内存占用呈线性飙升，最终突破 10GB 并导致程序崩溃。而理论上，即使是百万位的数字，所需的存储空间也仅为 MB 级别。

## 2. 抽丝剥茧：两大泄漏源

经过深入的 LLVM IR 代码审查和调试，我们确认了内存泄漏并非来自单一源头，而是由两个层面的设计缺陷共同导致的：

### 2.1 隐性杀手：循环变量的“前世今生”
**问题现象**：主循环中的 `c: bigint = a + b` 导致了巨大的内存黑洞。

**技术根源**：**静态编译误区**。
编译器在处理 `VarDecl`（变量声明）节点时，默认认为每遇到一次声明，就是创建了一个全新的变量。
- **静态视角**：代码里只有一行 `c: bigint = ...`。
- **动态视角**：在 `while` 循环中，这行代码被执行了百万次。
- **后果**：每次循环，编译器都生成新的 `malloc` 指令分配内存给指针 `c`，却从未生成代码去释放 `c` 在**上一轮循环**中持有的内存地址。指针 `c` 就像一只喜新厌旧的猴子，不断抓取新香蕉（内存），随手扔掉手里的旧香蕉，导致旧香蕉堆积如山。

### 2.2 显性杀手：指数爆炸的临时工
**问题现象**：BigInt 的乘法（Karatsuba 算法）和除法运算如果不加控制，内存消耗呈指数级增长。

**技术根源**：**中间结果未回收**。
Karatsuba 算法通过递归将大数拆解。例如计算 `A * B`，需要计算 `z0`, `z1`, `z2` 等多个中间 BigInt 对象。
- 在 Python 等高级语言中，GC（垃圾回收）会自动处理这些临时对象。
- 在我们手写的 LLVM IR 中，这些 `malloc` 出来的中间对象如果函数返回前不显式 `free`，它们就会永久驻留在堆中。一次深度递归可能产生数十个“孤儿”对象。

---

## 3. 破局之道：对症下药

### 3.1 修复循环泄漏：引入运行时检查 (Runtime Check)
我们修改了编译器代码生成逻辑 (`code_generator.py`)，打破了“声明即新建”的静态假设。

**修复方案**：
1.  **入口防御**：确保函数入口处，所有指针变量被 `NULL` 初始化。
2.  **动态清理**：将变量声明逻辑改为“先检查，后赋值”。

**伪代码对比**：
*   ❌ **旧逻辑**：
    ```c
    ptr = malloc(size); // 直接覆盖，旧值丢失
    ```
*   ✅ **新逻辑**：
    ```c
    if (ptr != NULL) {
        free(ptr->data); // 运行时自检：如果有旧值，先释放
        free(ptr);
    }
    ptr = malloc(size); // 再分配
    ```

这一改动（仅约 19 行代码）让编译器具备了处理循环作用域内资源复用的能力。

### 3.2 修复运算泄漏：RAII 手动模拟
我们修改了底层内置函数 (`builtins.py`)，在实现层面上模拟 RAII（资源获取即初始化）的析构过程。

**修复方案**：
1.  **定义 `free_bigint`**：封装释放引用计数和数据内存的标准动作。
2.  **清理现场**：在 `mul`, `div`, `mod` 等函数返回前，显式调用 `free_bigint` 清理所有局部临时变量。

例如在 Karatsuba 乘法末尾：
```python
# 清理十几个中间变量，防止递归泄漏
free_bigint(z0_tmp);
free_bigint(z1_tmp);
free_bigint(digits_low);
...
return result;
```

---

## 4. 经验总结

本次优化不仅仅是修复了一个 Bug，更是对编译器资源管理设计的一次深刻复盘：

1.  **静态与动态的鸿沟**：编译器开发者必须时刻警惕静态代码结构（AST）与动态执行流（CFG）之间的差异。循环体内的“声明”在运行时实际上是“赋值”或“重置”。
2.  **资源所有权 (Ownership)**：在没有 GC 的语言中，明确资源的所有权归属至关重要。究竟是变量拥有数据（需要负责释放），还是数据独立于变量（引用计数），必须在代码生成阶段就有清晰的界定。
3.  **防御性编程**：对于指针类型的变量，`Initialization to NULL` 是实现安全内存管理的最廉价且有效的手段。

通过这次优化，Meteor 语言的 BigInt 运算不仅跑得通，更跑得稳，证明了我们构建的内存模型经受住了百万级运算的考验。
